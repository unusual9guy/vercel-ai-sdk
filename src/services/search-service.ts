/**
 * Search Service
 * Coordinates search operations with Airweave
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, resolve } from 'path';
import type { SearchOptions, SearchResponse, SearchType, OutputFormat } from '../types/index.js';
import { airweaveClient } from '../lib/airweave.js';
import { appConfig } from '../config/env.js';

export class SearchService {
  private defaultSearchType: SearchType;
  private defaultLimit: number;
  private defaultOutputFormat: OutputFormat;
  private outputDir: string;

  constructor() {
    this.defaultSearchType = appConfig.defaultSearchType;
    this.defaultLimit = appConfig.maxResults;
    this.defaultOutputFormat = appConfig.defaultOutputFormat;
    this.outputDir = resolve(process.cwd(), 'outputs');
    
    if (!existsSync(this.outputDir)) {
      mkdirSync(this.outputDir, { recursive: true });
    }
  }

  async search(options: SearchOptions): Promise<SearchResponse> {
    return airweaveClient.search({
      query: options.query,
      searchType: options.searchType || this.defaultSearchType,
      limit: options.limit || this.defaultLimit,
    });
  }

  saveResultsToFile(query: string, response: SearchResponse, aiSummary?: string, keyPoints?: string[]): string {
    const safeFileName = this.sanitizeFileName(query);
    const filePath = join(this.outputDir, `${safeFileName}.md`);
    const markdown = this.formatAsMarkdown(query, response, aiSummary, keyPoints);
    writeFileSync(filePath, markdown, 'utf-8');
    return filePath;
  }

  private formatAsMarkdown(query: string, response: SearchResponse, aiSummary?: string, keyPoints?: string[]): string {
    const lines: string[] = [];
    
    lines.push(`# Search Results: "${query}"`);
    lines.push('');
    lines.push(`| Property | Value |`);
    lines.push(`|----------|-------|`);
    lines.push(`| Search Type | ${response.searchType} |`);
    lines.push(`| Total Results | ${response.totalResults} |`);
    lines.push(`| Processing Time | ${response.processingTime || 0}ms |`);
    lines.push(`| Generated | ${new Date().toLocaleString()} |`);
    lines.push('');
    lines.push('---');
    lines.push('');

    if (aiSummary) {
      lines.push('## ðŸ¤– AI Summary');
      lines.push('');
      lines.push(aiSummary);
      lines.push('');
      if (keyPoints && keyPoints.length > 0) {
        lines.push('**Key Points:**');
        lines.push('');
        keyPoints.forEach(point => lines.push(`- ${point}`));
        lines.push('');
      }
      lines.push('---');
      lines.push('');
    }

    lines.push('## ðŸ“Š Results');
    lines.push('');

    if (response.results.length === 0) {
      lines.push('*No results found.*');
    } else {
      response.results.forEach((result, index) => {
        const extracted = this.extractContent(result.content);
        const title = result.title || extracted.name || `Result ${index + 1}`;
        
        lines.push(`### ${index + 1}. ${title}`);
        lines.push('');
        
        // Quick info
        lines.push(`> **Type:** ${extracted.type || 'Unknown'} | **Source:** ${result.source} | **Score:** ${result.score.toFixed(4)}`);
        lines.push('');

        // Content
        if (extracted.content) {
          lines.push('```');
          lines.push(extracted.content);
          lines.push('```');
        } else {
          lines.push('*No content available*');
        }
        lines.push('');
        lines.push('---');
        lines.push('');
      });
    }

    lines.push('*Generated by Airweave Notion Search POC*');
    return lines.join('\n');
  }

  /**
   * Extract and clean content from raw Airweave response
   */
  private extractContent(rawContent: string): {
    name?: string;
    type?: string;
    content?: string;
  } {
    if (!rawContent) return {};

    try {
      const data = JSON.parse(rawContent);
      
      // Get basic info
      const result: ReturnType<typeof this.extractContent> = {
        name: data.name || data.title,
        type: data.type,
      };

      // Get the main text content
      let text = '';

      // Priority 1: textual_representation (most complete)
      if (data.textual_representation) {
        text = data.textual_representation;
      }
      // Priority 2: content field
      else if (data.content) {
        text = data.content;
      }
      // Priority 3: text field
      else if (data.text) {
        text = data.text;
      }

      // Clean and format the text
      if (text) {
        result.content = this.formatText(text);
      }

      return result;

    } catch {
      // Not JSON, clean as plain text
      return {
        content: this.formatText(rawContent),
      };
    }
  }

  /**
   * Format text - break inline lists, clean up formatting
   */
  private formatText(text: string): string {
    if (!text) return '';

    let result = text;

    // Remove metadata section completely
    result = result.replace(/# Metadata[\s\S]*?(?=# Content|$)/i, '');
    
    // Remove content header
    result = result.replace(/# Content\s*/i, '');

    // Handle **Content:** pattern
    const contentMatch = result.match(/\*\*Content\*\*:\s*([\s\S]+)/i);
    if (contentMatch) {
      result = contentMatch[1];
    }

    // Convert HTML
    result = result.replace(/<u>([^<]+)<\/u>/gi, '$1');
    result = result.replace(/<strong>([^<]+)<\/strong>/gi, '$1');
    result = result.replace(/<em>([^<]+)<\/em>/gi, '$1');
    result = result.replace(/<br\s*\/?>/gi, '\n');

    // MAIN FIX: Break inline numbered lists
    // Pattern: "1. text 2. text" -> "1. text\n2. text"
    result = result.replace(/\s+(\d+)\.\s+/g, '\n$1. ');

    // Break inline bullet lists  
    result = result.replace(/\s+[-â€¢]\s+/g, '\n- ');

    // Handle checkboxes
    result = result.replace(/\[x\]/gi, '[X]');
    result = result.replace(/\[\s*\]/gi, '[ ]');

    // Clean images
    result = result.replace(/!\[([^\]]*)\]\([^)]+\)/gi, '[Image: $1]');

    // Clean links - keep URL visible
    result = result.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1 ($2)');

    // Clean LaTeX
    result = result.replace(/\$\$([^$]+)\$\$/g, '[$1]');
    result = result.replace(/\$([^$\n]+)\$/g, '[$1]');

    // Remove markdown headers (convert to plain text)
    result = result.replace(/^#{1,6}\s*/gm, '');

    // Clean up escaped chars
    result = result.replace(/\\([^\w\s])/g, '$1');

    // Clean extra spaces
    result = result.replace(/[^\S\n]{2,}/g, ' ');

    // Clean up line breaks
    result = result.replace(/\n{3,}/g, '\n\n');

    // Trim lines
    result = result.split('\n').map(line => line.trim()).join('\n');

    return result.trim();
  }

  private sanitizeFileName(query: string): string {
    const safe = query
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .slice(0, 80);
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    return `${safe}_${timestamp}`;
  }

  getOutputDir(): string {
    return this.outputDir;
  }
}

export const searchService = new SearchService();
export default SearchService;
